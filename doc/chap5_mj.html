<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (aaa) - Chapter 5: 
    Transducer operations
  </title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap5"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap5.html">[MathJax off]</a></p>
<p><a id="X85FDD59A84876E36" name="X85FDD59A84876E36"></a></p>
<div class="ChapSects"><a href="chap5_mj.html#X85FDD59A84876E36">5 <span class="Heading">
    Transducer operations
  </span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X85FDD59A84876E36">5.1 <span class="Heading">
      Transducer operations
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7E016A6A8059C868">5.1-1 InverseTransducer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X804FAA85791C27B8">5.1-2 TransducerProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7915551D7C0AEAD4">5.1-3 RemoveStatesWithIncompleteResponse</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X792D723C7BA3A416">5.1-4 RemoveInaccessibleStates</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X83FF10F8855F4461">5.1-5 CombineEquivalentStates</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C7E085F82C657F3">5.1-6 MinimalTransducer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X86CB782483000595">5.1-7 CopyTransducerWithInitialState</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7E911F5F858920E9">5.1-8 TransducerConstantStateOutputs</a></span>
</div></div>
</div>

<h3>5 <span class="Heading">
    Transducer operations
  </span></h3>

<p>In this chapter we decribe the methods that are available in the <strong class="pkg">aaa</strong> package to perform operations on <strong class="pkg">aaa</strong> transducers. These methods are implementations of the algorithms introduced in <a href="chapBib_mj.html#biBGNS">[GNS00]</a>.</p>

<p><a id="X85FDD59A84876E36" name="X85FDD59A84876E36"></a></p>

<h4>5.1 <span class="Heading">
      Transducer operations
    </span></h4>

<p>The following are the methods that can be used to analyze <strong class="pkg">aaa</strong> transducers.</p>

<p><a id="X7E016A6A8059C868" name="X7E016A6A8059C868"></a></p>

<h5>5.1-1 InverseTransducer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseTransducer</code>( <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transducer.</p>

<p>For an invertible transducer <var class="Arg">T</var> whose first state is a homeomorphism state, the operation <code class="code">InverseTransducer(<var class="Arg">T</var>)</code> returns the inverse of <var class="Arg">T</var>. Please note that it is the user's responsibility to ensure that the transducer <var class="Arg">T</var> is both invertible and that its first state is a homeomorphism state.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Transducer(3, 3, [[1, 1, 2], [1, 3, 2], [1, 1, 2]], [[[2], [0], [1]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     [[0, 0], [], [1]], [[0, 2], [2], [0, 1]]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := InverseTransducer(f);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := TransducerFunction(f, [0, 1], 1)[1];</span>
[ 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransducerFunction(g, w, 1)[1];</span>
[ 0, 1 ]
</pre></div>

<p><a id="X804FAA85791C27B8" name="X804FAA85791C27B8"></a></p>

<h5>5.1-2 TransducerProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransducerProduct</code>( <var class="Arg">T</var>, <var class="Arg">P</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transducer.</p>

<p>For two transducers <var class="Arg">T</var> and <var class="Arg">P</var>, the operation <code class="code">TransducerProduct(<var class="Arg">T, P</var>)</code> returns the product of the transducers <var class="Arg">T</var> and <var class="Arg">P</var>. The product command can also be run with *. Moreover, if n is an integer, then the <var class="Arg">T</var>^n returns the product of <var class="Arg">T</var> with itself <var class="Arg">n</var> times (n may only be negative if <var class="Arg">T</var> is invertible). If <var class="Arg">T</var> is invertible, then the product T^-1*P*T can be input as P^T.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Transducer(3, 3, [[1, 1, 2], [1, 3, 2], [1, 1, 2]], [[[2], [0], [1]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     [[0, 0], [], [1]], [[0, 2], [2], [0, 1]]]);</span>
&lt;transducer with input alphabet on 3 symbols, output alphabet on 3 symbols,
  and 3 states.&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ff := TransducerProduct(f, f);</span>
&lt;transducer with input alphabet on 3 symbols, output alphabet on 3 symbols,
  and 9 states.&gt;
</pre></div>

<p><a id="X7915551D7C0AEAD4" name="X7915551D7C0AEAD4"></a></p>

<h5>5.1-3 RemoveStatesWithIncompleteResponse</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RemoveStatesWithIncompleteResponse</code>( <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transducer.</p>

<p>For a transducer <var class="Arg">T</var> that has states with incomplete response, the operation <code class="code">RemoveStatesWithIncompleteResponse(<var class="Arg">T</var>)</code> returns a transducer <code class="code">P</code> that has one more state than <var class="Arg">T</var>(acting as the new initial state) and which has no states with incomplete response. State <code class="code">s</code> of the transducer <var class="Arg">T</var> is state <code class="code">s + 1</code> of the transducer <code class="code">P</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := Transducer(3, 3, [[1, 1, 2], [1, 3, 2], [1, 1, 2]], [[[2], [0], []],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                          [[1, 0, 0], [1], [1]], [[0, 2], [2], [0]]]);</span>
&lt;transducer with input alphabet on 3 symbols, output alphabet on 3 symbols,
  and 3 states.&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := RemoveStatesWithIncompleteResponse(t);</span>
&lt;transducer with input alphabet on 3 symbols, output alphabet on 3 symbols,
  and 4 states.&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransducerFunction(t, [2], 1)[1]; TransducerFunction(t, [1], 2)[1];</span>
[  ]
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransducerFunction(p, [2], 2)[1];</span>
[ 1 ]
</pre></div>

<p><a id="X792D723C7BA3A416" name="X792D723C7BA3A416"></a></p>

<h5>5.1-4 RemoveInaccessibleStates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RemoveInaccessibleStates</code>( <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transducer.</p>

<p>For a transducer <var class="Arg">T</var>, the operation <code class="code">RemoveInaccessibleStates(<var class="Arg">T</var>)</code> returns the transducer that is obtained by removing the states that are not accesssible from state 1.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Transducer(3, 3, [[1, 1, 2], [1, 3, 2], [1, 1, 2]], [[[2], [0], [1]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     [[0, 0], [], [1]], [[0, 2], [2], [0, 1]]]);</span>
&lt;transducer with input alphabet on 3 symbols, output alphabet on 3 symbols,
  and 3 states.&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ff := TransducerProduct(f, f);</span>
&lt;transducer with input alphabet on 3 symbols, output alphabet on 3 symbols,
  and 9 states.&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := RemoveInaccessibleStates(ff);</span>
&lt;transducer with input alphabet on 3 symbols, output alphabet on 3 symbols,
  and 6 states.&gt;
</pre></div>

<p><a id="X83FF10F8855F4461" name="X83FF10F8855F4461"></a></p>

<h5>5.1-5 CombineEquivalentStates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CombineEquivalentStates</code>( <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transducer.</p>

<p>For a transducer <var class="Arg">T</var>, the operation <code class="code">CombineEquivalentStates(<var class="Arg">T</var>)</code> returns the transducer that is obtained by identifying states from which all finite words write the same word.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Transducer(2, 2, [[1, 3], [2, 1], [1, 1], [1, 3]], [[[0], [0]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">			   [[1, 1], [0]], [[0], [0, 1]], [[0], [0]]]);</span>
&lt;transducer with input alphabet on 2 symbols, output alphabet on 2 symbols,
and 4 states.&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T2 := CombineEquivalentStates(T);</span>
&lt;transducer with input alphabet on 2 symbols, output alphabet on 2 symbols, 
and 3 states.&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutputFunction(T);</span>
[ [ [ 0 ], [ 0 ] ], [ [ 1, 1 ], [ 0 ] ], [ [ 0 ], [ 0, 1 ] ], [ [ 0 ], [ 0 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransitionFunction(T);</span>
[ [ 1, 3 ], [ 2, 1 ], [ 1, 1 ], [ 1, 3 ] ]</pre></div>

<p><a id="X7C7E085F82C657F3" name="X7C7E085F82C657F3"></a></p>

<h5>5.1-6 MinimalTransducer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalTransducer</code>( <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transducer.</p>

<p>Every transducer has a minimal omega-equivalent form (this transducer produces the same outputs on all infinite length inputs as the original). One arrives at this form by first removing inaccessible states, then removing incomplete response from all states, and finally combining equivalent states. Those three operations are described above. For a transducer <var class="Arg">T</var>, the operation <code class="code">MinimalTransducer(<var class="Arg">T</var>)</code> returns the transducer's minimal omega-equivalent form.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Transducer(2, 2, [[1, 3], [2, 1], [1, 1], [1, 3]], [[[0], [0]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         [[1, 1], [0]], [[0], [0, 1]], [[0], [0]]]);</span>
&lt;transducer with input alphabet on 2 symbols, output alphabet on 2 symbols,
and 4 states.&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := MinimalTransducer(T);</span>
&lt;transducer with input alphabet on 2 symbols, output alphabet on 2 symbols, 
and 3 states.&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutputFunction(M);</span>
[ [ [ 0, 0, 0 ], [ 0, 0 ] ], [ [ 0 ], [  ] ], [ [ 0, 0 ], [ 1, 0, 0 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransitionFunction(M);</span>
[ [ 2, 3 ], [ 2, 3 ], [ 2, 2 ] ]
</pre></div>

<p><a id="X86CB782483000595" name="X86CB782483000595"></a></p>

<h5>5.1-7 CopyTransducerWithInitialState</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CopyTransducerWithInitialState</code>( <var class="Arg">T</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transducer.</p>

<p>For a transducer <var class="Arg">T</var> and a positive integer <var class="Arg">m</var>, the operation <code class="code">CopyTransducerWithInitialState(<var class="Arg">T, m</var>)</code> returns the transducer that is obtained by relabeling the states of <var class="Arg">T</var> such that state <var class="Arg">m</var> becomes state 1, but is otherwise equivalent to <var class="Arg">T</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Transducer(3, 3, [[1, 1, 2], [1, 3, 2], [1, 1, 2]], [[[2], [0], [1]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     [[0, 0], [], [1]], [[0, 2], [2], [0, 1]]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := CopyTransducerWithInitialState(f, 3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransducerFunction(f, [0, 1, 0], 3);</span>
[ [ 0, 2, 0, 2 ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransducerFunction(p, [0, 1, 0], 1);</span>
[ [ 0, 2, 0, 2 ], 2 ]
</pre></div>

<p><a id="X7E911F5F858920E9" name="X7E911F5F858920E9"></a></p>

<h5>5.1-8 TransducerConstantStateOutputs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransducerConstantStateOutputs</code>( <var class="Arg">T</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list.</p>

<p>If the transducer <var class="Arg">T</var> is degenerate, then this operation returns fail. A state of a trasducer is called constant if it induces a constant map from the space of infinite words in its input alphabet the the space of infinite words in its output alphabet. For a non-degenerate transducer <var class="Arg">T</var>, the operation <code class="code">TransducerConstantStateOutputs(<var class="Arg">T</var>)</code> returns a list containing two lists. The first is a list of the constant states of <var class="Arg">T</var>. The second is a list of the values taken by those states. Such a value is represented as a string "v(w)*" where v and w are finite strings in the output alphabet of <var class="Arg">T</var>. The string "v(w)*" represents the infinite word vwwwwww... (v and w are always chosen to be as short as possible).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Transducer(2, 2, [[1, 2], [2, 2]], [[[1], [1, 1]], [[1], [1, 1]]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransducerConstantStateOutputs(T);</span>
[ [ 1, 2 ], [ "(1)*", "(1)*" ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Transducer(2, 3, [[2, 3], [2, 3], [2, 3]], [[[2, 0], [2]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[1, 1, 0], [1, 1]], [[0], [0, 1, 1]]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Transducer(2, 2, [[1, 2], [2, 2]], [[[0], [1, 1]], [[1], [1, 1]]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransducerConstantStateOutputs(T);                                       </span>
[ [ 2 ], [ "(1)*" ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransducerConstantStateOutputs(T);</span>
[ [ 1, 2, 3 ], [ "2(011)*", "(110)*", "(011)*" ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Transducer(2, 2, [[3, 3], [1, 1], [2, 1]], [[[1], []],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[0, 1, 1, 1], [0]], [[0], [1]]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransducerConstantStateOutputs(T);</span>
[ [  ], [  ] ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
